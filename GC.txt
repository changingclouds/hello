方法区
堆
虚拟机栈
本地方法栈
程序计数器



哪些内存需要回收
什么时候回收
如何回收

	程序计数器、虚拟机栈、本地方法栈随着线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出有条不紊的执行着出栈入栈操作，
	每一个栈帧分配多少内存基本在类结构确定下来时就已知，因此这几个区域的内存分配和回收都具备确定性，所以这几个区域就不需要过多的考虑回收问题，
	因为方法结束或者线程结束内存自然就跟着回收了。
	
可达性分析算法
	通过一系列的称为GC Roots的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连接时，则证明此对象是不可用的。

生存还是死亡
	真正宣告一个对象死亡，至少要经历两次标记过程
	对象进行可达性分析发现没有与GC Roots相连接的引用链，那么它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize[ˈfaɪnəlaɪz]
	
回收方法区

垃圾收集算法
	标记清除算法
	复制算法
	标记整理算法
	分代收集算法

垃圾收集器
	young generation
	serial[ˈsɪəriəl]  parnew  parallel [ˈpærəlel] 
	
	
	tenured[ˈtenjə(r)]  generation[ˌdʒenəˈreɪʃn]
	CMS  serial old  parallel old



内存分配
	
	对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配）,
	对象主要分配在新生代的Eden区,如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。
	少数情况也可能直接分配到老年代,
	分配的规则非百分百固定，其细节取决于当前使用的哪一种垃圾收集器组合。
	
	对象优先在Eden[ˈi:dn]分配
	对象在新生代Eden区中没有足够空间进行分配时，虚拟机将发起一次Minor[ˈmaɪnə(r)] GC
	如果对象无法放入Survivor[səˈvaɪvə(r)] 空间，将通过分配担保机制提前转移到老年代
	新生代GC Minor GC
	老年代GC Major[ˈmeɪdʒə(r)]  GC
	
	大对象直接进入老年代
	
	长期存活的对象进入老年代
	既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时必须能识别哪些对象应放在新生代，哪些对象应放在老年代中，
	虚拟机给每个对象定义了一个对象年龄计数器。
	如果对象在Eden出生并经过一次Minor GC 后仍然存活，并且能够被survivor容纳的话，将被移动到survivor中，并且将对象年龄设为1，
	对象在survivor区中没熬过一次Minor GC年龄就增加一岁 年龄增加到15将会晋升到老年代中。
	
	动态对象年龄判定
	为了更好的适应不同程序的内存状况，虚拟机并不是永远要求对象的年龄必须达到XX,
	如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入到老年代。
	
	空间分配担保
	发生Minor Gc之前虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，那么MinorGC 确保安全。
	如果不成立查看handlePromotionfailure设置是否允许担保失败允许 MinorGC 不允许就提前触发Full GC。
	冒险的概念
	新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间作为轮换，当大量对象在Minor GC后依然存活，就需要
	老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代，
	老年代要进行这样的担保，前提就是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，
	所以只好去每一次回收晋升到老年代对象容量的平均大小作为经验值，
	担保失败后重新发起一次Full GC。
	
	
	
